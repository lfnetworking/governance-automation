# =============================================================================
#  LFN Project Governance Automation Workflow  ¬∑  *Option¬†C*  (auto‚Äëdiscover repos)
#  --------------------------------------------------------------------------------
#  PURPOSE
#  -------
#  ‚Ä¢ Crawl every repository that belongs to an LFN umbrella project (or a single
#    induction‚Äëcandidate repo) and collect activity, contributor and release
#    metrics **without** requiring special GraphQL scopes.
#  ‚Ä¢ Classify each repository into one of *seven* lifecycle phases defined by
#    the TAC (Spark¬†‚Üí¬†Incubation¬†‚Üí¬†Active Development¬†‚Üí¬†Stable¬†‚Üí¬†Maintenance/LTS
#    ‚Üí¬†Archive¬†‚Üí¬†Inaccessible).
#  ‚Ä¢ Publish a Markdown summary (and Slack ping) so PMs & TAC can immediately
#    see repos that may need attention.
#  ‚Ä¢ Designed to be **readable & hackable**¬†‚Äì heavy commentary is included below
#    so anyone in the community can follow or tweak the logic.
#
#  CHANGELOG (‚úÇ¬†trim as needed)
#  ---------
#  2025‚Äë04‚Äë17‚Äën
#    ‚Ä¢ Re‚Äëimplemented metrics collection *purely* via REST ‚Äì eliminates the
#      GraphQL token‚Äëscope issue that forced every repo into "Inaccessible".
#    ‚Ä¢ Added a lightweight auth‚Äëdebug step so token problems are surfaced early.
#    ‚Ä¢ Added in‚Äëfile documentation and **expanded lifecycle‚Äëphase commentary**.
# =============================================================================

# -----------------------------------------------------------------------------
#  WORKFLOW METADATA
# -----------------------------------------------------------------------------
name: "LFN¬†Project Governance Automation"

# -----------------------------------------------------------------------------
#  TRIGGERS
#  ‚Ä¢ Manual trigger via *workflow_dispatch* so staff can run ad‚Äëhoc reviews.
#  ‚Ä¢ Scheduled trigger every Monday¬†09:00¬†UTC (‚âà¬†02:00¬†Pacific) for weekly review
# -----------------------------------------------------------------------------
on:
  # ---------- Manual ----------
  workflow_dispatch:
    inputs:
      mode:          # "review" (default)  ‚ûú crawl everything defined in projects.yaml
                      # "induction"         ‚ûú evaluate a *single* candidate repo
        description: "Choose the run mode"
        required: true
        default: "review"
        type: choice
        options: [review, induction]
      project_org:    # Only used for *induction* runs
        description: "(induction) GitHub org where the new project lives"
        required: false
      project_repo:   # Only used for *induction* runs
        description: "(induction) Repository slug <org>/<repo>"
        required: false
  # ---------- Cron ----------
  schedule:
    - cron: "0 9 * * 1"   # 09:00¬†UTC Monday ‚Üí 02:00¬†PT

# -----------------------------------------------------------------------------
#  PERMISSIONS
#  We explicitly list scopes needed by the workflow so that the minted GITHUB_TOKEN
#  follows the principle of least privilege.
# -----------------------------------------------------------------------------
permissions:
  contents: read      # read‚Äëonly access to repos
  issues:   write     # create / update governance issue
  pull-requests: write
  id-token: write     # required by upload‚Äëartifact OIDC path

# -----------------------------------------------------------------------------
#  GLOBAL ENVIRONMENT
#  The GitHub CLI (`gh`) is used throughout; we inject a long‚Äëlived PAT stored in
#  repo secrets so it can access *all* LFN orgs.
# -----------------------------------------------------------------------------
env:
  GH_TOKEN: ${{ secrets.LFN_ADMIN_TOKEN }}

# -----------------------------------------------------------------------------
#  JOB: enumerate-projects
#  -----------------------
#  Build a *matrix* of <org>/<repo> slugs to process.  In normal "review" mode we
#  read `.lfn/projects.yaml` (checked into this repo) which lists the umbrella
#  orgs.  In "induction" mode we only need the single candidate repo provided by
#  the workflow_dispatch inputs.
# -----------------------------------------------------------------------------
jobs:
  enumerate-projects:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      # ---- 1. Checkout repo (for projects.yaml) ----
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # ---- 2. yq ‚Äì handy YAML CLI ----
      - name: Install yq
        run: sudo apt-get update -y && sudo apt-get install -y yq

      # ---- 3. Build JSON matrix ----
      - name: Build repo matrix
        id: set-matrix
        shell: bash
        env:
          MODE: ${{ github.event.inputs.mode || 'review' }}
          PROJECT_ORG: ${{ github.event.inputs.project_org }}
          PROJECT_REPO: ${{ github.event.inputs.project_repo }}
        run: |
          set -euo pipefail
          if [[ "$MODE" == "induction" ]]; then
            # Manual single‚Äërepo run
            echo "matrix=[\"${PROJECT_ORG}/${PROJECT_REPO}\"]" >> "$GITHUB_OUTPUT"
          else
            # Auto‚Äëdiscover all repos for each org listed in projects.yaml
            declare -a matrix
            for org in $(yq -r '.orgs[]' .lfn/projects.yaml); do
              echo "üì¶ $org" >&2
              for repo in $(gh repo list "$org" --json name -q '.[].name'); do
                matrix+=("$org/$repo")
              done
            done
            # Emit JSON array so matrix strategy can consume
            printf '%s\n' "${matrix[@]}" | jq -R . | jq -cs '.' | {
              read json; echo "matrix=$json" >> "$GITHUB_OUTPUT"; echo "Matrix: $json" >&2; }
          fi

  # ---------------------------------------------------------------------------
  #  JOB: classify  (runs **once per repo** in the matrix)
  #  -----------------------------------------------------
  #  ‚Ä¢ Fetch basic repo metadata via REST
  #  ‚Ä¢ Derive activity & contributor statistics
  #  ‚Ä¢ Map to one of the seven lifecycle phases
  #  ‚Ä¢ Upload a tiny artifact <org>--<repo>.json with { phase }
  # ---------------------------------------------------------------------------
  classify:
    needs: enumerate-projects
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repo_slug: ${{ fromJson(needs.enumerate-projects.outputs.matrix) }}
    steps:
      # ---- sanity: show auth status so missing scopes are obvious ----
      - name: GitHub CLI auth debug
        run: |
          echo "== gh auth status ==" && gh auth status || true
        env:
          GH_TOKEN: ${{ secrets.LFN_ADMIN_TOKEN }}

      # ---- 1. Collect raw repo JSON (REST) ----
      - name: Collect repository metrics (REST‚Äëonly)
        id: metrics
        shell: bash
        env:
          REPO: ${{ matrix.repo_slug }}
        run: |
          set -euo pipefail
          owner="${REPO%%/*}"
          repo="${REPO#*/}"
          # Use gh api ‚Üí writes repo.json or empty {}
          if ! gh api "/repos/$owner/$repo" > repo.json 2>err.log; then
            echo "‚ö†Ô∏è  $REPO ‚Äì $(cat err.log)" >&2
            echo '{}' > repo.json
          fi
          echo "json=$(cat repo.json)" >> "$GITHUB_OUTPUT"

      # -------------------------------------------------------------------
      # 2. DETERMINE LIFECYCLE PHASE  üóÇÔ∏è
      # -------------------------------------------------------------------
      # This is *the* brains of the workflow.  The embedded JavaScript (via
      # actions/github-script) digests the raw REST metadata plus a few extra
      # on‚Äëthe‚Äëfly queries (contributors, commits, releases) and assigns the
      # repository to one of seven TAC‚Äëapproved lifecycle phases.
      #
      #  ‚ÑπÔ∏è  DETAILED RUBRIC & THRESHOLDS
      #  ----------------------------------------------------------------
      #  ‚Ä¢ Spark  ‚Äì‚ÄÉ<¬†3 contributors *OR* no formal release.
      #  ‚Ä¢ Incubation ‚Äì‚ÄÉ‚â•¬†3 contributors **and** at least one formal release.
      #  ‚Ä¢ Active Development ‚Äì‚ÄÉHigh velocity (‚â§¬†30¬†days since last push **and**
      #                         ‚â•¬†20 commits in the past 90¬†days).
      #  ‚Ä¢ Stable ‚Äì‚ÄÉSlower cadence (last push between 30‚Äì180¬†days).
      #  ‚Ä¢ Maintenance/LTS ‚Äì‚ÄÉProject age ‚â•¬†5¬†yrs, last push 6‚Äì18¬†months, and
      #                       a release issued within the last 2¬†yrs.
      #  ‚Ä¢ Archive ‚Äì‚ÄÉRepository explicitly archived (`archived: true`).
      #  ‚Ä¢ Inaccessible ‚Äì‚ÄÉMetadata could not be fetched (e.g., perms/network).
      #
      #  The numeric cut‚Äëoffs were derived from empirical activity patterns across
      #  LFN‚Äëhosted projects and purposely err on the *conservative* side‚Äîi.e.,
      #  a repo will not be promoted too aggressively.  Tuning these knobs is a
      #  one‚Äëline change to the constants below.
      # -------------------------------------------------------------------
      - name: Determine lifecycle phase (7‚Äëphase rubric)
        id: phase
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.LFN_ADMIN_TOKEN }}
          script: |
            /* ------------------------------------------------------------------
               Lifecycle Phase Evaluation Logic  ‚Äì *verbose edition*
               ------------------------------------------------------------------
               Inputs (injected via env):
                 ‚Ä¢ REPO_JSON  ‚Äì stringified REST metadata for the repo.
                 ‚Ä¢ REPO_SLUG  ‚Äì "org/repo".

               Additional live queries performed here:
                 ‚Ä¢ listContributors()     ‚Üí unique contributor count.
                 ‚Ä¢ listCommits(since=90d) ‚Üí commit velocity.
                 ‚Ä¢ getLatestRelease()     ‚Üí presence & recency of releases.

               Helper functions:
                 daysAgo(isoDate) ‚Äì returns floating‚Äëpoint days since the event.

               ------------------------------------------------------------------
               PHASE‚ÄëSPECIFIC HEURISTICS
               ------------------------------------------------------------------
               ‚Ä¢ Spark (a.k.a. *Candidate*)
                   - Intended for brand‚Äënew or seed‚Äëhand‚Äëoff code.
                   - < 3 contributors **OR** no GitHub release tag.

               ‚Ä¢ Incubation
                   - Early community forming.
                   - ‚â• 3 contributors **AND** ‚â• 1 release.
                   - Activity/quality may still be unstable; that is okay.

               ‚Ä¢ Active Development
                   - Rapid development.
                   - Last push ‚â§ 30¬†days ago **AND** ‚â• 20 commits in last 90¬†days.

               ‚Ä¢ Stable
                   - Code is feature‚Äëcomplete; patches flow but slower.
                   - Last push between 30¬†and 180¬†days.

               ‚Ä¢ Maintenance / LTS
                   - Long‚Äërunning, production deployments.
                   - Project age ‚â• 5¬†years.
                   - Last push 180‚Äì540¬†days (‚âà¬†6‚Äì18¬†months).
                   - A *recent* release (‚â§ 730¬†days) confirms periodic upkeep.

               ‚Ä¢ Archive
                   - GitHub "archive" switch flipped ‚Üí hard stop.

               ‚Ä¢ Inaccessible
                   - REST call failed (private repo, deleted, permissions, etc.).

               Anything that slips through defaults to "Unknown" so the TAC can
               manually inspect and decide.
            ------------------------------------------------------------------*/
            const repo   = JSON.parse(process.env.REPO_JSON || '{}');
            const slug   = process.env.REPO_SLUG || '';
            const [owner, repoName] = slug.split('/');

            // Convenience: days between now and an ISO timestamp ----------------
            const daysAgo = iso => (Date.now() - new Date(iso)) / 864e5;

            // ------------------------------------------------------------
            //  PRIMARY DECISION MATRIX  üîç
            // ------------------------------------------------------------
            let phase = 'Unknown';

            if (!Object.keys(repo).length) {
              // Could not retrieve metadata (network, perms, etc.)
              phase = 'Inaccessible';
            } else if (repo.archived) {
              // Explicitly archived by maintainers.
              phase = 'Archive';
            } else {
              //----------------------------------------------------------------
              // Fetch supplementary metrics live ‚Äì keeps token scope minimal
              //----------------------------------------------------------------
              let contributors = 0;
              try {
                const { data: contrib } = await github.rest.repos.listContributors({ owner, repo: repoName, per_page: 100, anon: true });
                contributors = contrib.length;
              } catch (_) { /* ignore & default to 0 */ }

              const silent       = daysAgo(repo.pushed_at || repo.updated_at); // how long since any push?
              const ageYrs       = (Date.now() - new Date(repo.created_at)) / (365 * 864e5);

              // -- release info -------------------------------------------------
              let lastRelDays = Infinity;
              let hasRelease  = false;
              try {
                const { data: rel } = await github.rest.repos.getLatestRelease({ owner, repo: repoName });
                lastRelDays = daysAgo(rel.published_at);
                hasRelease  = true;
              } catch (_) { /* no release found */ }

              // -- commit velocity (90¬†days) -----------------------------------
              let commits90d = 0;
              try {
                const since = new Date(Date.now() - 90 * 864e5).toISOString();
                const commits = await github.paginate(github.rest.repos.listCommits, { owner, repo: repoName, since, per_page: 100 });
                commits90d = commits.length;
              } catch (_) { /* network hiccup */ }

              //----------------------------------------------------------------
              //  Apply rubric  ‚Üí set `phase`
              //----------------------------------------------------------------
              const isSpark   = contributors < 3 || !hasRelease;
              const isIncub   = !isSpark && contributors >= 3 && hasRelease;
              const isActive  = !isSpark && commits90d >= 20 && silent <= 30;
              const isStable  = !isSpark && !isActive && silent > 30 && silent <= 180;
              const isLTS     = !isSpark && ageYrs >= 5 && silent > 180 && silent <= 540 && lastRelDays <= 730;

              if      (isSpark)  phase = 'Spark';
              else if (isIncub)  phase = 'Incubation';
              else if (isActive) phase = 'Active Development';
              else if (isStable) phase = 'Stable';
              else if (isLTS)    phase = 'Maintenance / LTS';
              else               phase = 'Unknown';  // catch‚Äëall / needs manual eyes
            }

            // Publish outputs & side‚Äëfile for later aggregation ---------------
            core.setOutput('phase', phase);
            const fs = require('fs');
            fs.writeFileSync('repo.json', JSON.stringify({ phase }, null, 2));
        env:
          REPO_JSON: ${{ steps.metrics.outputs.json }}
          REPO_SLUG: ${{ matrix.repo_slug }}

      # ---- 3. Name artifact safely (replace / with --) ----
      - name: Sanitize artifact name
        shell: bash
        env:
          REPO: ${{ matrix.repo_slug }}
        run: |
          safe="${REPO//\//--}"
          echo "ART_NAME=$safe" >> $GITHUB_ENV

      # ---- 4. Upload { phase } result ----
      - name: Upload result
        uses: actions/upload-artifact@v4
        with:
          name: "${{ env.ART_NAME }}.json"
          path: repo.json

  # ---------------------------------------------------------------------------
  #  JOB: publish-report (runs **once** after all classify jobs)  --------------
  #  ‚Ä¢ Stitch individual artifacts into a Markdown dashboard grouped by project.
  #  ‚Ä¢ Post/Update a GitHub Issue labelled `lfn-governance`.
  #  ‚Ä¢ Optionally ping Slack (webhook secret optional).
  # ---------------------------------------------------------------------------
  publish-report:
    needs: classify
    runs-on: ubuntu-latest
    if: always()
    steps:
      # ---- 1. Download all <org>--<repo>.json artifacts ----
      - uses: actions/download-artifact@v4
        with:
          path: artifacts

      # ---- 2. Build Markdown summary + add to job summary ----
      - id: build-md
        shell: bash
        run: |
          set -euo pipefail
          declare -A rows   # associative array keyed by project/org
          for dir in artifacts/*; do
            [[ -d "$dir" ]] || continue
            slug=$(basename "$dir")
            slug=${slug%.json}
            full=${slug//--/\/}      # re‚Äëhydrate to org/repo
            project=${full%%/*}
            repo=${full#*/}
            phase=$(jq -r '.phase // "Unknown"' "$dir/repo.json" 2>/dev/null || echo Unknown)
            if [[ -n "${rows[$project]:-}" ]]; then rows[$project]+=$'\n'; fi
            rows[$project]+="| $repo | $phase |"
          done
          {
            echo "# LFN Project Lifecycle Summary"
            for project in "${!rows[@]}"; do
              echo
              echo "## $project"
              echo "| Repository | Phase |"
              echo "|------------|-------|"
              printf '%s\n' "${rows[$project]}" | sort
            done
          } > summary.md
          {
            echo 'summary<<EOF'
            cat summary.md
            echo EOF
          } >> "$GITHUB_OUTPUT"
          cat summary.md >> "$GITHUB_STEP_SUMMARY"

      # ---- 3. Create/Update governance issue ----
      - uses: actions
