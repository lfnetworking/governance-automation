# =============================================================================
#  LFN Project Governance Automation Workflow
#  --------------------------------------------------------------------------------
#  PURPOSE
#  -------\n#  This workflow aims to provide consistency and engagement to the governance and health-check processes for Projects across all Linux Foundation Networking (LFN) projects. It regularly assesses repositories under LFN's umbrella to ensure continuous alignment with community health, security standards, and lifecycle progression defined by the Technical Advisory Council (TAC). This information will be helpful to the Members of the Board when making strategic decisions.
#  The timing of the assessment would depend on their lifecycle phase and the metrics being checked. The timing will need to be customizable by the TAC.

#  CORE OBJECTIVES
#  ---------------
#  • **Automated Repository Assessment:**
#    - Periodically scan every repository within the LFN umbrella projects (and induction-candidate repositories).
#    - Read existing health metrics, including commit activity, contributor engagement, release history, and lifecycle status.
#    - Initially designed to operate without requiring elevated permissions or special GitHub GraphQL scopes, ensuring secure, transparent, and community-friendly operation.

#  • **Lifecycle Classification:**
#    - Clearly categorize repositories into one of seven TAC-defined lifecycle phases:
#      1. Spark (Candidate)
#      2. Incubation
#      3. Active Development
#      4. Stable
#      5. Maintenance / LTS
#      6. Archive
#      7. Inaccessible (e.g., private, deleted)
#    - Use a configurable rules engine (`classify-config.yml`) to define the thresholds for each phase based on the collected metrics.

#  • **Automated Reporting & Issue Creation:**
#    - Generate a consolidated Markdown summary report of all assessed repositories, grouped by project and sorted by phase.
#    - Post this summary to the workflow run's summary page for easy visibility.
#    - (Optional) Create or update a dedicated governance issue within each repository, providing phase-specific guidance and linking to the full report (requires `issues: write` permission).
#    - (Optional) Send a notification to a configured Slack channel upon completion.

#  • **Community Engagement:**
#    - Provide transparent, data-driven insights into project health and lifecycle status.
#    - Offer actionable, phase-appropriate suggestions to project maintainers via the generated issues.
#    - Foster proactive governance discussions within the LFN community.
# =============================================================================

name: LFN Project Governance Automation

on:
  # Allows manual triggering from the GitHub Actions UI
  workflow_dispatch:

  # Schedule to run automatically (e.g., weekly on Sunday at midnight UTC)
  schedule:
    - cron: '0 0 * * 0' # Adjust schedule as needed by TAC

  # Optional: Trigger on pushes to specific config files (for testing/updates)
  # push:
  #   branches:
  #     - main
  #   paths:
  #     - '.github/workflows/lfn-project-governance.yml'
  #     - '.github/workflows/classify-config.yml'
  #     - '.lfn/projects.yaml'
  #     - 'classify-config/**'

# Environment variables available to all jobs
env:
  PROJECT_CONFIG_PATH: '.lfn/projects.yaml'
  CLASSIFY_CONFIG_PATH: '.github/workflows/classify-config.yml'
  ISSUES_CONFIG_PATH: '.github/workflows/issues-config.yml' # Path to issue templates
  CLASSIFY_ACTION_PATH: './classify-config' # Path to the local JS action
  GOVERNANCE_ISSUE_TITLE: "Quarterly LFN Governance & Lifecycle Review" # Standard title for created issues

permissions:
  contents: read      # Read repo content, list repos in org
  issues: write       # Create/update governance issues (if enabled)
  pull-requests: write # Needed by some actions, can potentially be reduced if not strictly needed

jobs:
  # ===========================================================================
  # 1. List Repositories Job
  #    Reads the project config file and lists all repositories to be evaluated.
  # ===========================================================================
  list-repos:
    runs-on: ubuntu-latest
    outputs:
      repos: ${{ steps.get-repos.outputs.repositories }}
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install yq (YAML processor)
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq

      - name: Read Orgs from Config
        id: read-orgs
        run: |
          orgs=$(yq -o=json '.orgs' ${{ env.PROJECT_CONFIG_PATH }})
          echo "orgs=$orgs" >> $GITHUB_OUTPUT

      - name: Get Repositories for Each Org
        id: get-repos
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const orgs = JSON.parse('${{ steps.read-orgs.outputs.orgs }}');
            let allRepos = [];
            for (const org of orgs) {
              core.info(`Fetching repositories for organization: ${org}`);
              try {
                const iterator = github.paginate.iterator(github.rest.repos.listForOrg, {
                  org: org,
                  type: 'public', // Consider 'all' if private repos under LFN need assessment (requires different permissions)
                  per_page: 100,
                });
                for await (const { data: repos } of iterator) {
                  for (const repo of repos) {
                    if (!repo.archived) { // Skip archived repositories here
                       allRepos.push(`${org}/${repo.name}`);
                    } else {
                       core.info(`Skipping archived repository: ${org}/${repo.name}`);
                    }
                  }
                }
              } catch (error) {
                 core.warning(`Could not list repositories for org "${org}". It might not exist, or token lacks permissions. Error: ${error.message}`);
                 // Optionally, fail the workflow if listing is critical:
                 // core.setFailed(`Failed to list repositories for org "${org}": ${error.message}`);
              }
            }
            core.info(`Found ${allRepos.length} non-archived public repositories.`);
            // Output as a JSON string array
            return JSON.stringify(allRepos);
        # Store the result in the step output
        result-encoding: string

      - name: Generate Matrix for Classification Job
        id: generate-matrix
        run: |
          repos_json='${{ steps.get-repos.outputs.result }}'
          # Create a JSON object suitable for a matrix strategy
          matrix_json=$(echo "$repos_json" | jq '{ "include": [ (.[] | { "repo": . }) ] }')
          echo "matrix=${matrix_json}" >> $GITHUB_OUTPUT
          echo "Generated Matrix:"
          echo "$matrix_json" | jq .

  # ===========================================================================
  # 2. Classify Repositories Job (Matrix)
  #    Runs in parallel for each repository identified in the 'list-repos' job.
  #    Uses the local JavaScript action to determine the lifecycle phase.
  # ===========================================================================
  classify:
    needs: list-repos
    if: ${{ needs.list-repos.outputs.matrix != 'null' && fromJson(needs.list-repos.outputs.matrix).include[0] != null }} # Only run if repos were found
    runs-on: ubuntu-latest
    permissions:
      contents: read      # Needed by classify action to read repo data
      issues: read        # Potentially needed if classify action checks issues
      pull-requests: read # Potentially needed if classify action checks PRs
      # Add other permissions if the classify action needs them (e.g., metadata: read)
    strategy:
      matrix: ${{ fromJson(needs.list-repos.outputs.matrix) }}
      fail-fast: false # Allow other matrix jobs to continue if one fails

    steps:
      - name: Checkout Code (for local action)
        uses: actions/checkout@v4
        with:
          # Fetch depth 0 might be needed if your action relies on full git history
          # fetch-depth: 0

      - name: Setup Node.js (for local action)
        uses: actions/setup-node@v4
        with:
          node-version: '16' # Match the version specified in classify-config/action.yml

      - name: Install Dependencies (for local action)
        run: npm install
        working-directory: ${{ env.CLASSIFY_ACTION_PATH }}

      - name: Run Classification Action
        id: classify-repo
        uses: ${{ env.CLASSIFY_ACTION_PATH }} # Use the local action
        with:
          repo: ${{ matrix.repo }}
          config_path: ${{ env.CLASSIFY_CONFIG_PATH }}
          # Pass the token if the action needs it explicitly (it usually gets it from env)
          # token: ${{ secrets.GITHUB_TOKEN }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Ensure token is available

      - name: Echo Phase Output
        run: echo "Repository ${{ matrix.repo }} classified as: ${{ steps.classify-repo.outputs.phase }}"

      # Upload the result (repo name + phase) as an artifact.
      # Artifact name uses '--' as separator for org/repo, easy to parse later.
      - name: Upload Classification Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ replace(matrix.repo, '/', '--') }}.json # e.g., lfn-infra--releng-sandbox.json
          path: ${{ env.CLASSIFY_ACTION_PATH }}/repo.json # Path where the action saves its output JSON
          retention-days: 5 # Keep artifacts for a few days

  # ===========================================================================
  # 3. Publish Report Job
  #    Collects all classification artifacts and generates a summary report.
  #    Optionally creates/updates governance issues in each repository.
  # ===========================================================================
  publish-report:
    needs: classify
    if: always() # Run even if some classification jobs failed, to report on successes
    runs-on: ubuntu-latest
    permissions:
      contents: read # To read repository metadata if needed
      issues: write  # Required to create/update issues

    steps:
      - name: Checkout Code (for issue templates/scripts)
        uses: actions/checkout@v4

      - name: Download All Classification Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts # Download all artifacts into the 'artifacts' directory
          # The action automatically creates subdirectories named after the artifacts

      - name: List Downloaded Artifacts (for debugging)
        run: ls -R artifacts

      - name: Generate Summary Report
        id: generate-summary
        shell: bash
        run: |
          set -euo pipefail
          # Check if jq is installed, install if necessary
          if ! command -v jq &> /dev/null; then
            echo "jq not found, installing..." >&2
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

          declare -A rows_data # Associative array: key=project, value=multiline string of "| repo | phase |" rows
          echo "Scanning artifacts directory: $(pwd)/artifacts" >&2
          # Loop through artifact directories created by download-artifact
          # Structure is artifacts/<artifact-name>/repo.json

          # --- START FIX ---
          # Use process substitution (< <(...)) to read files without a subshell for the loop
          while IFS= read -r -d $'\0' file; do
          # --- END FIX ---
            dir=$(dirname "$file")
            slug=$(basename "$dir") # Slug is like 'org--repo.json'

            # Extract the original artifact name (e.g., org--repo.json)
            artifact_name_with_ext=$(basename "$dir")
            # Remove .json extension
            artifact_name=${artifact_name_with_ext%.json}

            # Restore original slug format (org/repo) from artifact name
            full=${artifact_name//--/\/}
            project=${full%%/*}
            repo=${full#*/}

            if [[ -f "$file" ]]; then
              phase=$(jq -r '.phase // "Unknown"' "$file" 2>/dev/null)
              # Handle potential jq errors or null values explicitly
              if [[ -z "$phase" ]] || [[ "$phase" == "null" ]]; then
                phase="Unknown"
                echo "Warning: Could not parse phase or phase was null in $file ($artifact_name). Setting to Unknown." >&2
              fi
            else
              phase="Unknown (Missing JSON)"
              echo "Warning: repo.json not found in $dir ($artifact_name)" >&2
            fi

            # Store the formatted table row line for this repo under its project key
            row_line="| [$repo](https://github.com/$project/$repo) | $phase |" # Add Markdown link
            # Append using newline as a separator
            if [[ -z "${rows_data[$project]:-}" ]]; then # Check if key exists using parameter expansion
              rows_data[$project]="$row_line"
            else
              rows_data[$project]+=$'\n'"$row_line"
            fi
          # --- START FIX ---
          done < <(find artifacts -mindepth 2 -maxdepth 2 -name '*.json' -print0) # Find any .json file inside the artifact subdirs
          # --- END FIX ---

          # Check if any rows were generated
          if [ ${#rows_data[@]} -eq 0 ]; then
            echo "WARNING: No valid artifact data found to generate report." >&2
            echo "# LFN Project Lifecycle Summary" > summary.md
            echo "" >> summary.md
            echo "*No project data processed successfully. Check the 'classify' job logs for errors.*" >> summary.md
          else
            # Now generate the markdown AFTER collecting all data
            {
              echo "# LFN Project Lifecycle Summary"
              echo ""
              echo "Generated on: $(date -u)"
              echo "Workflow Run: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}>"
              echo ""
              # Sort projects alphabetically by iterating through sorted keys
              # Use printf and sort to handle keys safely
              sorted_projects=()
              while IFS= read -r key; do
                  sorted_projects+=("$key")
              done < <(printf '%s\n' "${!rows_data[@]}" | sort)

              for project in "${sorted_projects[@]}"; do
                echo
                echo "## $project"
                echo "| Repository | Phase |"
                echo "|------------|-------|"
                # Sort the lines for the current project by phase (column 2), then repo name (column 1)
                # Use process substitution again for sorting
                mapfile -t sorted_lines < <(printf '%s\n' "${rows_data[$project]}" | sort -t'|' -k3,3 -k2,2) # Sort by phase (field 3), then repo (field 2)
                # Print the sorted lines from the indexed array
                printf '%s\n' "${sorted_lines[@]}"
              done
            } > summary.md
          fi

          echo "Generated summary.md:" >&2
          cat summary.md >&2

          # Set output using recommended heredoc approach for multiline strings
          {
            echo 'summary<<EOF'
            cat summary.md
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          # Add to job summary for easy viewing in Actions UI
          cat summary.md >> "$GITHUB_STEP_SUMMARY"

      # --- Optional: Create/Update Governance Issue ---
      # This section iterates through the processed artifacts again
      # to create/update an issue in each repository.
      # Requires 'issues: write' permission.
      # Set CREATE_ISSUES=true to enable.
      - name: Create/Update Governance Issues (Optional)
        if: env.CREATE_ISSUES == 'true' # Control via environment variable or remove 'if' to always run
        env:
          CREATE_ISSUES: false # SET TO true TO ENABLE ISSUE CREATION
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const yaml = require('js-yaml');

            const issuesConfigPath = process.env.ISSUES_CONFIG_PATH;
            const governanceIssueTitle = process.env.GOVERNANCE_ISSUE_TITLE;
            const artifactsDir = './artifacts';
            let issueTemplates = {};

            core.info(`Attempting to load issue templates from: ${issuesConfigPath}`);
            if (fs.existsSync(issuesConfigPath)) {
              try {
                const config = yaml.load(fs.readFileSync(issuesConfigPath, 'utf8'));
                issueTemplates = config.issues || {};
                core.info(`Loaded issue templates for phases: ${Object.keys(issueTemplates).join(', ')}`);
              } catch (e) {
                core.warning(`Could not parse issues config file at ${issuesConfigPath}: ${e.message}`);
              }
            } else {
              core.warning(`Issue config file not found at ${issuesConfigPath}. Cannot create/update issues.`);
              return; // Exit script if config is missing
            }

            const artifactDirs = fs.readdirSync(artifactsDir, { withFileTypes: true })
                                   .filter(dirent => dirent.isDirectory())
                                   .map(dirent => dirent.name);

            if (artifactDirs.length === 0) {
              core.info("No artifact directories found, skipping issue creation.");
              return;
            }

            core.info(`Found ${artifactDirs.length} artifact directories to process for issues.`);

            for (const artifactDirName of artifactDirs) {
              const jsonFilePath = path.join(artifactsDir, artifactDirName, 'repo.json'); // Assuming the JSON is always named repo.json
              if (!fs.existsSync(jsonFilePath)) {
                core.warning(`repo.json not found in artifact directory ${artifactDirName}, skipping issue creation.`);
                continue;
              }

              let repoData;
              try {
                repoData = JSON.parse(fs.readFileSync(jsonFilePath, 'utf8'));
              } catch (e) {
                core.warning(`Failed to parse ${jsonFilePath}: ${e.message}`);
                continue;
              }

              const repoSlug = repoData.repo; // Should be in "owner/repo" format from the classify action
              const phase = repoData.phase;

              if (!repoSlug || !phase) {
                core.warning(`Missing repo or phase in ${jsonFilePath}`);
                continue;
              }

              const [owner, repo] = repoSlug.split('/');
              if (!owner || !repo) {
                core.warning(`Invalid repo slug format in ${jsonFilePath}: ${repoSlug}`);
                continue;
              }

              core.info(`Processing issue for ${owner}/${repo} (Phase: ${phase})`);

              const template = issueTemplates[phase];
              if (!template) {
                core.info(`No issue template defined for phase '${phase}'. Skipping issue creation for ${owner}/${repo}.`);
                continue;
              }

              // Prepare issue content
              const title = template.title || governanceIssueTitle; // Use specific title or default
              // Simple placeholder replacement for now. Could be more sophisticated.
              const body = (template.body || `Governance review for ${repo}. Current phase: **${phase}**`)
                           .replace('', `*Repository:* ${repo}\n*Detected Phase:* ${phase}\n\n*Full Report:* <${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}>`);
              const labels = template.labels || ['lfn-governance']; // Use specific labels or default
              const assignees = template.assignees || []; // Use specific assignees or none

              try {
                // Check for existing open governance issue
                const { data: existingIssues } = await github.rest.issues.listForRepo({
                  owner,
                  repo,
                  state: 'open',
                  labels: labels.join(','), // Filter by labels to find the specific issue
                  creator: 'github-actions[bot]' // Filter by creator if possible/reliable
                });

                // More robust check: filter by title as well, as labels might be removed
                const existing = existingIssues.find(issue => issue.title === title && issue.user.login === 'github-actions[bot]');

                if (existing) {
                  core.info(`Found existing issue #${existing.number} for ${owner}/${repo}. Updating...`);
                  await github.rest.issues.update({
                    owner,
                    repo,
                    issue_number: existing.number,
                    body: body // Update the body with the latest info
                    // Optionally: Add a comment instead of updating the body
                    // await github.rest.issues.createComment({ owner, repo, issue_number: existing.number, body: `Governance review update: Phase is now ${phase}. See run: ...` });
                  });
                  core.info(`Updated issue #${existing.number}`);
                } else {
                  core.info(`No existing governance issue found for ${owner}/${repo}. Creating new issue...`);
                  await github.rest.issues.create({
                    owner,
                    repo,
                    title,
                    body,
                    labels: labels,
                    assignees: assignees
                  });
                  core.info(`Created new governance issue in ${owner}/${repo}`);
                }
              } catch (error) {
                // Handle common errors gracefully
                if (error.status === 404) {
                   core.warning(`Repository ${owner}/${repo} not found or issues are disabled. Skipping.`);
                } else if (error.status === 403) {
                   core.warning(`Permission denied for creating/updating issues in ${owner}/${repo}. Check token permissions (needs issues:write). Skipping.`);
                } else {
                   core.error(`Failed to create or update governance issue for ${owner}/${repo}: ${error.message}`);
                   // Optionally set failed for critical errors: core.setFailed(...)
                }
                console.error("Error details:", error); // Log full error for debugging
              }
            } // end for loop over artifacts

      # Optional notification to Slack channel (if webhook is configured)
      - name: Notify Slack (optional)
        if: env.SLACK_WEBHOOK_URL != '' && steps.generate-summary.outcome == 'success' # Only notify on success
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ":clipboard: *LFN Project Governance Summary Generated*"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    { "type": "mrkdwn", "text": "*Workflow:*\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Run>" },
                    { "type": "mrkdwn", "text": "*Triggered by:*\n${{ github.event_name }}" }
                  ]
                },
                {
                   "type": "divider"
                },
                {
                   "type": "section",
                   "text": {
                      "type": "mrkdwn",
                      "text": "Summary added to workflow page."
                   }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }} # Store webhook URL as a secret
