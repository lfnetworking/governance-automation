# =============================================================================
#  LFN Project Governance Automation Workflow
#  --------------------------------------------------------------------------------
#  PURPOSE
#  -------
#  This workflow aims to provide consistency and engagement to the governance and health-check processes for Projects across all Linux Foundation Networking (LFN) projects. It regularly assesses repositories under LFN's umbrella to ensure continuous alignment with community health, security standards, and lifecycle progression defined by the Technical Advisory Council (TAC). This information will be helpful to the Members of the Board when making strategic decisions.
#  The timing of the assessment would depend on their lifecycle phase and the metrics being checked. The timing will need to be customizable by the TAC.

#  CORE OBJECTIVES
#  ---------------
#  â€¢ **Automated Repository Assessment:**
#    - Periodically scan every repository within the LFN umbrella projects (and induction-candidate repositories).
#    - Read existing health metrics, including commit activity, contributor engagement, release history, and lifecycle status.
#    - Initially designed to operate without requiring elevated permissions or special GitHub GraphQL scopes, ensuring secure, transparent, and community-friendly operation.

#  â€¢ **Lifecycle Classification:**
#    - Clearly categorize repositories into one of seven TAC-defined lifecycle phases:
#      1. Spark (Candidate/New)
#      2. Incubation
#      3. Active Development
#      4. Stable
#      5. Maintenance/Long-Term Support (LTS)
#      6. Archive
#      7. Inaccessible (permissions issue or repository not found)
#    - Provide a simple, community-readable summary for easy tracking and oversight by project maintainers, Program Managers (PMs), and the TAC.

#  â€¢ **Friendly and Encouraging Community Engagement:**
#    - Automatically create/update one GitHub issue per organization (project-level) with clear, friendly, and actionable next-step suggestions to improve their project's lifecycle status.
#    - Issues will not impose strict deadlines, emphasizing encouragement and constructive guidance, with recommended adjustable check-ins for progress updates.
#    - Repositories classified as "Archive" or "Inaccessible" are intentionally excluded from next-step issues as they have reached terminal phases.

#  FUTURE ENHANCEMENTS
#  -------------------
#  â€¢ **Security and Health:**
#    - Incorporate OSSF Scorecard checks
#    - Open tickets to the orgs (project-level) with helpful steps they can take to improve their current OSSF scorecard
#
#  â€¢ **Governance and Leadership:**
#    - Technical Steering Committee (TSC) membership is often submitted as part of Induction levels beyond Spark (and possibly even at Spark), but it is not always maintained in GitHub.  With community
#      agreement, it may be easier to maintain in GitHub for automation, if we can agree on a standard
#
#  â€¢ **Flexible TAC Lifecycle Adjustment:**
#    - Provide a clear, documented mechanism to modify lifecycle phase datapoints based on official TAC approvals (authentication of approvals currently outside workflow scope, maintained by LF staff or authorized community maintainers for now discuss with community).

#  READABILITY & MAINTAINABILITY
#  -----------------------------
#  This workflow is intentionally designed to be both verbose and structured for readability and ease of community collaboration. Community members are encouraged to contribute suggestions, enhancements, or adjustments to the logic to ensure continuous improvement and alignment with community goals.

name: "LFN Project Governance Automation"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Choose the run mode"
        required: true
        default: "test"
        type: choice
        options: [test, review, induction]
      project_org:
        description: "(induction) GitHub org where the new project lives"
        required: false
      project_repo:
        description: "(induction) Repository slug <org>/<repo>"
        required: false
  schedule:
    - cron: "0 9 * * 1"  # 09:00 UTC Monday â†’ 02:00 PT

permissions:
  contents: read
  issues: write
  pull-requests: write
  id-token: write

env:
  GITHUB_TOKEN: ${{ secrets.LFN_ADMIN_TOKEN }}

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ðŸ“¦ Enumerate Projects: Builds the list of repositories to process based on
  #    .lfn/projects.yaml or specific project slug (for induction mode)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  enumerate-projects:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      # Checkout this repository so that .lfn/projects.yaml can be read
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Installs yq so YAML can be parsed in shell script below
      - name: Install yq
        run: sudo apt-get update -y && sudo apt-get install -y yq jq # Also ensure jq is installed here

      # Create the matrix of repos to scan. If mode is 'induction' use input slug, else scan .lfn config
      - name: Build repo matrix
        id: set-matrix
        shell: bash
        env:
          MODE: ${{ github.event.inputs.mode || 'review' }}
          PROJECT_ORG: ${{ github.event.inputs.project_org }}
          PROJECT_REPO: ${{ github.event.inputs.project_repo }}
        run: |
          set -euo pipefail
          # Ensure gh is installed and authenticated if needed
          if ! command -v gh &> /dev/null; then echo "ERROR: gh cli not found." >&2; exit 1; fi

          if [[ "$MODE" == "induction" ]]; then
            if [[ -z "$PROJECT_REPO" ]]; then echo "ERROR: Project repo slug must be provided for induction mode." >&2; exit 1; fi
            if ! echo "$PROJECT_REPO" | grep -q '/'; then echo "ERROR: Project repo slug must be in <org>/<repo> format." >&2; exit 1; fi
            echo "matrix=[\"${PROJECT_REPO}\"]" >> "$GITHUB_OUTPUT"
            echo "Matrix (Induction): [\"${PROJECT_REPO}\"]" >&2
          else
            if [[ ! -f ".lfn/projects.yaml" ]]; then echo "ERROR: .lfn/projects.yaml not found!" >&2; exit 1; fi
            declare -a matrix
            for org in $(yq -r '.orgs[] // ""' .lfn/projects.yaml); do
              if [[ -z "$org" ]]; then continue; fi # Skip empty org entries
              echo "ðŸ“¦ Processing org: $org" >&2
              repo_list_json=$(GH_TOKEN=${{ env.GITHUB_TOKEN }} gh repo list "$org" --limit 1000 --json name -q '.' 2>/dev/null) # Pass token explicitly if needed
              if [[ $? -ne 0 ]] || [[ -z "$repo_list_json" ]] || [[ "$repo_list_json" == "[]" ]]; then
                  echo "WARNING: Failed to list repos for '$org' or org is empty/inaccessible." >&2
                  continue
              fi
              while IFS= read -r repo_name; do
                  if [[ -n "$repo_name" ]]; then matrix+=("$org/$repo_name"); fi
              done < <(echo "$repo_list_json" | jq -r '.[].name')
            done

            if [ ${#matrix[@]} -eq 0 ]; then
              echo "ERROR: No repositories found to process after scanning .lfn/projects.yaml." >&2
              exit 1
            fi

            printf '%s\n' "${matrix[@]}" | jq -R . | jq -cs '.' | {
              read json; echo "matrix=$json" >> "$GITHUB_OUTPUT"; echo "Matrix Size: ${#matrix[@]}" >&2; echo "Matrix Content (sample): $(echo $json | cut -c 1-200)..." >&2; }
          fi

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ðŸ§ª Classify: Classifies each repo based on metrics and classify-config.yml
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  classify:
    needs: enumerate-projects
    # Prevent running if the matrix is empty
    if: ${{ needs.enumerate-projects.outputs.matrix != '[]' && needs.enumerate-projects.outputs.matrix != '' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repo_slug: ${{ fromJson(needs.enumerate-projects.outputs.matrix) }}
    steps:

      # Step 1: Checkout governance-automation
      - name: Checkout governance-automation
        uses: actions/checkout@v4
        with:
          ref: main # Explicitly check out main

      # Step 2: Debug Step 1 (Optional - Can be removed later)
      - name: Check workspace IMMEDIATELY after main checkout
        run: |
          echo "## Debug: Contents of workspace (${{ github.workspace }}) after checking out governance-automation:"
          ls -la ${{ github.workspace }}
          echo "## Debug: Checking existence of ${{ github.workspace }}/classify-config"
          if [ -d "${{ github.workspace }}/classify-config" ]; then
            echo "OK: Directory ${{ github.workspace }}/classify-config found."
          else
            echo "ERROR: Directory ${{ github.workspace }}/classify-config NOT FOUND immediately after checkout!"
          fi
          echo "-----------------------------------------------------"

      # Step 3: Checkout target repo
      - name: Checkout target repo (${{ matrix.repo_slug }})
        id: checkout_target # ID for referencing outcome/conclusion
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo_slug }}
          path: repo
          fetch-depth: 1
        continue-on-error: true # Correct placement

      # Step 3.1: DEBUG - Check Checkout Outcome and Conclusion (Optional - Can be removed later)
      - name: DEBUG - Check Checkout Outcome and Conclusion (${{ matrix.repo_slug }})
        if: always()
        run: |
          echo "Outcome of step 'checkout_target': [${{ steps.checkout_target.outcome }}]"
          echo "Conclusion of step 'checkout_target': [${{ steps.checkout_target.conclusion }}]"
          echo "------------------------------------"

      # Step 4: Create default/error result file
      - name: Create default/error result file (${{ matrix.repo_slug }})
        run: |
          phase_value="Unknown"
          if [[ "${{ steps.checkout_target.conclusion }}" != "success" ]]; then # Checks conclusion
            phase_value="Checkout Failed"
            echo "::warning::Target repository checkout failed (conclusion: ${{ steps.checkout_target.conclusion }}). Setting phase to Checkout Failed."
          fi
          # Ensure the JSON is valid even if phase_value contains special chars (unlikely here)
          printf '{"phase": "%s"}\n' "$phase_value" > repo.json
          echo "Created initial repo.json with phase: ${phase_value}"

      # Step 5: Setup Node.js
      - name: Setup Node.js (${{ matrix.repo_slug }})
        if: steps.checkout_target.conclusion == 'success' # Uses conclusion
        uses: actions/setup-node@v4
        with:
          node-version: '16'

      # Step 6: Debug Step 2 (Optional - Can be removed later)
      - name: Check workspace BEFORE installing dependencies (${{ matrix.repo_slug }})
        if: steps.checkout_target.conclusion == 'success' # Uses conclusion
        run: |
          echo "## Debug: Contents of workspace (${{ github.workspace }}) just before npm install:"
          ls -la ${{ github.workspace }}
          echo "## Debug: Checking existence of ${{ github.workspace }}/classify-config just before npm install"
          if [ -d "${{ github.workspace }}/classify-config" ]; then
            echo "OK: Directory ${{ github.workspace }}/classify-config found."
          else
            echo "ERROR: Directory ${{ github.workspace }}/classify-config NOT FOUND just before npm install!"
          fi
          echo "-----------------------------------------------------"

      # Step 7: Install dependencies
      - name: Install Action Dependencies (${{ matrix.repo_slug }})
        if: steps.checkout_target.conclusion == 'success' # Uses conclusion
        run: npm install # Using install as package-lock might be missing/stale
        working-directory: ${{ github.workspace }}/classify-config

      # Step 7.1: DEBUG - Check node_modules after install (Optional - Can be removed later)
      - name: DEBUG - Check node_modules after install (${{ matrix.repo_slug }})
        if: steps.checkout_target.conclusion == 'success' # Uses conclusion
        run: |
          echo "Listing contents of classify-config AFTER npm install:"
          ls -la ${{ github.workspace }}/classify-config
          echo "Checking for node_modules/js-yaml:"
          if [ -d "${{ github.workspace }}/classify-config/node_modules/js-yaml" ]; then
            echo "OK: node_modules/js-yaml directory found."
          else
            echo "ERROR: node_modules/js-yaml directory NOT FOUND!"
            echo "Listing node_modules contents (if it exists):"
            ls -la ${{ github.workspace }}/classify-config/node_modules || echo "node_modules directory itself not found!"
          fi
          echo "------------------------------------"

      # Step 8: Run local action
      - name: Run classification action (${{ matrix.repo_slug }})
        id: classification
        if: steps.checkout_target.conclusion == 'success' # Uses conclusion
        uses: ./classify-config
        with:
          repo: ${{ matrix.repo_slug }}
          config_path: .github/workflows/classify-config.yml

      # Step 9: Sanitize name
      - name: Sanitize artifact name (${{ matrix.repo_slug }})
        id: sanitize
        run: echo "safe_name=$(echo ${{ matrix.repo_slug }} | sed 's|/|--|g')" >> $GITHUB_OUTPUT

      # Step 10: DEBUG - Check repo.json before upload (Optional - Can be removed later)
      - name: DEBUG - Check repo.json before upload (${{ matrix.repo_slug }})
        if: always()
        run: |
          echo "Checking final state before upload for ${{ matrix.repo_slug }}:"
          echo "pwd: $(pwd)"
          echo "ls -la . :"
          ls -la .
          echo "--- Content of repo.json: ---"
          cat repo.json || echo "repo.json NOT FOUND right before upload!"
          echo "-----------------------------"

      # Step 11: Upload result
      - name: Upload classification result (${{ matrix.repo_slug }})
        uses: actions/upload-artifact@v4
        with:
          name: "${{ steps.sanitize.outputs.safe_name }}.json"
          path: repo.json

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ðŸ“‹ Publish Report: Aggregates results and posts Markdown summary to GitHub Issue
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  publish-report:
    needs: classify
    runs-on: ubuntu-latest
    if: always() # Run even if classify jobs fail to generate partial report
    steps:
      # Downloads all previously uploaded repo.json files for processing
      - name: Download classification artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts # Download all artifacts into artifacts/ directory

      # Parses all JSON files into Markdown summary grouped by project
      - name: Build Markdown Report
        id: build-md
        shell: bash
        # --- SCRIPT MODIFIED TO FIX SUBSHELL ISSUE ---
        run: |
          set -euo pipefail
          # Check if jq is installed, install if necessary
          if ! command -v jq &> /dev/null; then
            echo "jq not found, installing..." >&2
            sudo apt-get update -y && sudo apt-get install -y jq
          fi

          declare -A rows_data # Associative array: key=project, value=multiline string of "| repo | phase |" rows
          echo "Scanning artifacts directory: $(pwd)/artifacts" >&2
          # Loop through artifact directories created by download-artifact
          # Structure is artifacts/<artifact-name>/<some-name>.json

          # Use process substitution to read files without a subshell for the loop
          while IFS= read -r -d $'\0' file; do
            dir=$(dirname "$file")
            # Extract artifact name (e.g., org--repo.json) from the directory name
            artifact_name_with_ext=$(basename "$dir")
            # Remove .json extension
            artifact_name=${artifact_name_with_ext%.json}

            # Restore original slug format (org/repo) from artifact name
            full=${artifact_name//--/\/}
            project=${full%%/*}
            repo=${full#*/}

            if [[ -f "$file" ]]; then
              phase=$(jq -r '.phase // "Unknown"' "$file" 2>/dev/null)
              # Handle potential jq errors or null values explicitly
              if [[ -z "$phase" ]] || [[ "$phase" == "null" ]]; then
                phase="Unknown"
                echo "Warning: Could not parse phase or phase was null in $file ($artifact_name). Setting to Unknown." >&2
              fi
            else
              # This case should ideally not happen if the classify job always creates a file
              phase="Unknown (Missing JSON)"
              echo "Warning: repo.json not found in $dir ($artifact_name)" >&2
            fi

            # Store the formatted table row line for this repo under its project key
            row_line="| [$repo](https://github.com/$project/$repo) | $phase |" # Add Markdown link
            # Append using newline as a separator
            if [[ -z "${rows_data[$project]:-}" ]]; then # Check if key exists using parameter expansion
              rows_data[$project]="$row_line"
            else
              rows_data[$project]+=$'\n'"$row_line"
            fi
          # --- FIX APPLIED HERE ---
          done < <(find artifacts -mindepth 2 -maxdepth 2 -name '*.json' -print0) # Find any .json file inside the artifact subdirs


          # Check if any rows were generated
          if [ ${#rows_data[@]} -eq 0 ]; then
            echo "WARNING: No valid artifact data found to generate report." >&2
            echo "# LFN Project Lifecycle Summary" > summary.md
            echo "" >> summary.md
            echo "*No project data processed successfully. Check the 'classify' job logs for errors.*" >> summary.md
          else
            # Now generate the markdown AFTER collecting all data
            {
              echo "# LFN Project Lifecycle Summary"
              echo ""
              echo "Generated on: $(date -u)"
              echo "Workflow Run: <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}>"
              echo ""
              # Sort projects alphabetically by iterating through sorted keys
              # Use printf and sort to handle keys safely
              sorted_projects=()
              while IFS= read -r key; do
                  sorted_projects+=("$key")
              done < <(printf '%s\n' "${!rows_data[@]}" | sort)

              for project in "${sorted_projects[@]}"; do
                echo
                echo "## $project"
                echo "| Repository | Phase |"
                echo "|------------|-------|"
                # Sort the lines for the current project by phase (column 2), then repo name (column 1)
                # Use process substitution again for sorting
                mapfile -t sorted_lines < <(printf '%s\n' "${rows_data[$project]}" | sort -t'|' -k3,3 -k2,2) # Sort by phase (field 3), then repo (field 2)
                # Print the sorted lines from the indexed array
                printf '%s\n' "${sorted_lines[@]}"
              done
            } > summary.md
          fi

          echo "Generated summary.md:" >&2
          cat summary.md >&2

          # Set output using recommended heredoc approach
          {
            echo 'summary<<EOF'
            cat summary.md
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          # Add to job summary for easy viewing in Actions UI
          cat summary.md >> "$GITHUB_STEP_SUMMARY"
        # --- END OF SCRIPT ---

      # Updates or creates a governance issue on the repo with the report content
      - name: Create or update governance issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GITHUB_TOKEN }} # Use env var consistent with other steps
          script: |
            const fs = require('fs');
            // const core = require('@actions/core'); // Already removed
            // const github = require('@actions/github'); // Already removed
            // const context = github.context; // Already removed

            let body = "Failed to read summary.md";
            // Check if file exists before reading
            if (fs.existsSync('summary.md')) {
              body = fs.readFileSync('summary.md', 'utf8');
            } else {
              core.warning("summary.md not found for issue creation/update."); // 'core' is provided by github-script
              body = "Error: Workflow failed to generate summary report.";
            }

            const owner = context.repo.owner; // 'context' is provided by github-script
            const repo = context.repo.repo;   // 'context' is provided by github-script
            const title = 'Automated LFN Project Lifecycle Summary';
            const token = process.env.GITHUB_TOKEN; // Using env var as before

            if (!token) {
              // This check might be redundant if the action fails without a token, but good practice
              core.setFailed('GITHUB_TOKEN not found in environment.');
              return;
            }

            // Use the pre-authenticated 'github' object directly
            // const octokit = github.getOctokit(token); // <--- REMOVED THIS LINE

            try {
              // Find existing issue with the specific title and label
              // Use 'github' which is the pre-authenticated octokit instance
              const issues = await github.paginate(github.rest.issues.listForRepo, {
                owner, repo, labels: 'lfn-governance', state: 'open'
              });
              const existing = issues.find(i => i.title === title);

              if (existing) {
                core.info(`Found existing issue #${existing.number}. Updating...`);
                // Use 'github' which is the pre-authenticated octokit instance
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: existing.number,
                  body
                });
                core.info(`Updated issue #${existing.number}`);
              } else {
                core.info("No existing governance issue found. Creating new issue...");
                 // Use 'github' which is the pre-authenticated octokit instance
                await github.rest.issues.create({
                  owner,
                  repo,
                  title,
                  body,
                  labels: ['lfn-governance']
                });
                core.info('Created new governance issue');
              }
            } catch (error) {
              core.setFailed(`Failed to create or update governance issue: ${error.message}`);
              console.error("Error details:", error);
            }

      # Optional notification to Slack channel (if webhook is configured)
      - name: Notify Slack (optional)
        if: ${{ env.SLACK_WEBHOOK_URL != '' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": ":clipboard: LFN governance summary updated for *${{ github.repository }}* â€“ <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|view run>"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
