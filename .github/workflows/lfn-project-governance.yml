# =============================================================================
#  LFN Project Governance Automation Workflow · *Option C* (auto‑discover repos)
#  --------------------------------------------------------------------------------
#  PURPOSE
#  -------
#  • Crawl every repository that belongs to an LFN umbrella project (or a single
#    induction‑candidate repo) and collect activity, contributor and release
#    metrics **without** requiring special GraphQL scopes.
#  • Classify each repository into one of *seven* lifecycle phases defined by
#    the TAC (Spark → Incubation → Active Development → Stable → Maintenance/LTS
#    → Archive → Inaccessible).
#  • Publish a Markdown summary (and Slack ping) so PMs & TAC can immediately
#    see repos that may need attention.
#  • Designed to be **readable & hackable** – heavy commentary is included below
#    so anyone in the community can follow or tweak the logic.
#
#  CHANGELOG (✂ trim as needed)
#  ---------
#  2025‑04‑17‑p
#    • Added *verbose, line‑by‑line comments* inside the lifecycle‑phase
#      classifier to make the decision rubric crystal‑clear.
#    • No runtime logic changes.
# =============================================================================

name: "LFN Project Governance Automation"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Choose the run mode"
        required: true
        default: "review"
        type: choice
        options: [review, induction]
      project_org:
        description: "(induction) GitHub org where the new project lives"
        required: false
      project_repo:
        description: "(induction) Repository slug <org>/<repo>"
        required: false
  schedule:
    - cron: "0 9 * * 1"   # 09:00 UTC Monday → 02:00 PT

permissions:
  contents: read
  issues:   write
  pull-requests: write
  id-token: write

env:
  GH_TOKEN: ${{ secrets.LFN_ADMIN_TOKEN }}

jobs:
  enumerate-projects:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install yq
        run: sudo apt-get update -y && sudo apt-get install -y yq

      - name: Build repo matrix
        id: set-matrix
        shell: bash
        env:
          MODE: ${{ github.event.inputs.mode || 'review' }}
          PROJECT_ORG: ${{ github.event.inputs.project_org }}
          PROJECT_REPO: ${{ github.event.inputs.project_repo }}
        run: |
          set -euo pipefail
          if [[ "$MODE" == "induction" ]]; then
            echo "matrix=[\"${PROJECT_ORG}/${PROJECT_REPO}\"]" >> "$GITHUB_OUTPUT"
          else
            declare -a matrix
            for org in $(yq -r '.orgs[]' .lfn/projects.yaml); do
              echo "📦 $org" >&2
              for repo in $(gh repo list "$org" --json name -q '.[].name'); do
                matrix+=("$org/$repo")
              done
            done
            printf '%s\n' "${matrix[@]}" | jq -R . | jq -cs '.' | {
              read json; echo "matrix=$json" >> "$GITHUB_OUTPUT"; echo "Matrix: $json" >&2; }
          fi

  classify:
    needs: enumerate-projects
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repo_slug: ${{ fromJson(needs.enumerate-projects.outputs.matrix) }}
    steps:
      - name: GitHub CLI auth debug
        run: |
          echo "== gh auth status ==" && gh auth status || true
        env:
          GH_TOKEN: ${{ secrets.LFN_ADMIN_TOKEN }}

      - name: Collect repository metrics (REST‑only)
        id: metrics
        shell: bash
        env:
          REPO: ${{ matrix.repo_slug }}
        run: |
          set -euo pipefail
          owner="${REPO%%/*}"
          repo="${REPO#*/}"
          if ! gh api "/repos/$owner/$repo" > repo.json 2>err.log; then
            echo "⚠️  $REPO – $(cat err.log)" >&2
            echo '{}' > repo.json
          fi
          echo "json=$(cat repo.json)" >> "$GITHUB_OUTPUT"

      - name: Determine lifecycle phase (7‑phase rubric)
        id: phase
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.LFN_ADMIN_TOKEN }}
          script: |
            /* -------------------------------------------------------------------------
             *  LIFECYCLE CLASSIFICATION LOGIC (Spark → Incubation → Active → Stable → LTS
             *  → Archive → Inaccessible)
             *  -----------------------------------------------------------------------
             *  This block ingests a minimal *repo.json* produced by the previous step
             *  and derives a PHASE string.  We purposefully rely **only** on public
             *  REST v3 endpoints so that the workflow can run with the default GITHUB_TOKEN.
             *
             *  ────────────────  METRICS WE EXTRACT ─────────────────
             *   • contributors   – unique identities ever contributing code (proxy diversity)
             *   • commits90d     – commits in the rolling 90‑day window (proxy velocity)
             *   • silent         – days since last push (proxy dormancy)
             *   • ageYrs         – project age in *years*
             *   • lastRelDays    – days since the most recent GitHub Release
             *   • hasRelease     – boolean shortcut (≥1 release exists)
             *
             *  ────────────────  DECISION PLAYBOOK ───────────────────
             *   1.  Inaccessible  → API call failed (private/moved/deleted).
             *   2.  Archive       → GitHub “archived” flag true.
             *   3.  Spark         → very small (<3 contrib) OR zero releases.
             *   4.  Incubation    → enough contrib (≥3) *and* at least one release,
             *                       but still low velocity / early adoption.
             *   5.  Active Dev    → ≥20 commits in 90 days **and** last push ≤30 days.
             *   6.  Stable        → No longer active dev, but push within 30‑180 days.
             *   7.  Maintenance   → Age ≥5 yrs, low activity (>180 days) *yet* produced
             *                       a release within the last 2 years (≤730 days).
             *
             *  We break ties by checking the more *specific* phases first. For instance,
             *  a repo can be both Active *and* Incubation, but Active wins due to order.
             * ------------------------------------------------------------------------- */

            const repoJson  = JSON.parse(process.env.REPO_JSON || '{}');
            const slug      = process.env.REPO_SLUG || '';
            const [owner, repoName] = slug.split('/');

            // Helper – convert ISO dates → days delta
            const daysAgo = iso => (Date.now() - new Date(iso)) / 864e5;

            // ────────────────────── 1 · DEFAULT → Unknown ──────────────────────
            let phase = 'Unknown';

            // ────────────────────── 2 · INACCESSIBLE ───────────────────────────
            if (!Object.keys(repoJson).length) {
              phase = 'Inaccessible';
            }
            // ────────────────────── 3 · ARCHIVE (explicit flag) ────────────────
            else if (repoJson.archived) {
              phase = 'Archive';
            } else {
              /* Grab dynamic repo activity figures.  We wrap each call in a try/catch so
               * a 404 or rate‑limit for an individual endpoint doesn’t abort the workflow.
               */

              // → unique contributor count (overall)
              let contributors = 0;
              try {
                const { data: contrib } = await github.rest.repos.listContributors({
                  owner, repo: repoName, per_page: 100, anon: true });
                contributors = contrib.length;
              } catch (_) {/* swallow */}

              // → dormancy (days since last push)
              const silent = daysAgo(repoJson.pushed_at ?? repoJson.updated_at);

              // → project age in years
              const ageYrs = (Date.now() - new Date(repoJson.created_at)) / (365 * 864e5);

              // → latest release age (if any)
              let lastRelDays = Infinity;
              let hasRelease  = false;
              try {
                const { data: rel } = await github.rest.repos.getLatestRelease({ owner, repo: repoName });
                lastRelDays = daysAgo(rel.published_at);
                hasRelease  = true;
              } catch (_) {/* no releases */}

              // → commit velocity (rolling 90 days)
              let commits90d = 0;
              try {
                const sinceISO = new Date(Date.now() - 90 * 864e5).toISOString();
                const commits  = await github.paginate(github.rest.repos.listCommits, {
                  owner, repo: repoName, since: sinceISO, per_page: 100 });
                commits90d = commits.length;
              } catch (_) {}

              /*  Boolean helper flags for readability  */
              const isSpark  = (contributors < 3) || !hasRelease;
              const isIncub  = !isSpark && contributors >= 3 && hasRelease;
              const isActive = commits90d >= 20 && silent <= 30;
              const isStable = !isActive && silent > 30 && silent <= 180;
              const isLTS    = ageYrs >= 5 && silent > 180 && silent <= 540 && lastRelDays <= 730;

              // ────────────────────── FINAL PHASE CHOICE ───────────────────────
              if      (isSpark)  phase = 'Spark';
              else if (isIncub)  phase = 'Incubation';
              else if (isActive) phase = 'Active Development';
              else if (isStable) phase = 'Stable';
              else if (isLTS)    phase = 'Maintenance / LTS';
              else               phase = 'Unknown'; // fallback (should be rare)
            }

            core.setOutput('phase', phase);
            // Persist for the publish job
            const fs = require('fs');
            fs.writeFileSync('repo.json', JSON.stringify({ phase }, null, 2));
        env:
          REPO_JSON: ${{ steps.metrics.outputs.json }}
          REPO_SLUG: ${{ matrix.repo_slug }}

      - name: Sanitize artifact name
        shell: bash
        env:
          REPO: ${{ matrix.repo_slug }}
        run: |
          safe="${REPO//\//--}"
          echo "ART_NAME=$safe" >> $GITHUB_ENV

      - name: Upload result
        uses: actions/upload-artifact@v4
        with:
          name: "${{ env.ART_NAME }}.json"
          path: repo.json

  publish-report:
    needs: classify
    runs-on: ubuntu-latest
    if: always()
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: artifacts

      - id: build-md
        shell: bash
        run: |
          set -euo pipefail
          declare -A rows
          for dir in artifacts/*; do
            [[ -d "$dir" ]] || continue
            slug=$(basename "$dir")
            slug=${slug%.json}
            full=${slug//--/\/}
            project=${full%%/*}
            repo=${full#*/}
            phase=$(jq -r '.phase // "Unknown"' "$dir/repo.json" 2>/dev/null || echo Unknown)
            if [[ -n "${rows[$project]:-}" ]]; then rows[$project]+=$'\n'; fi
            rows[$project]+="| $repo | $phase |"
          done
          {
            echo "# LFN Project Lifecycle Summary"
            for project in "${!rows[@]}"; do
              echo
              echo "## $project"
              echo "| Repository | Phase |"
              echo "|------------|-------|"
              printf '%s\n' "${rows[$project]}" | sort
            done
          } > summary.md
          echo 'summary<<EOF' >> "$GITHUB_OUTPUT"
          cat summary.md >> "$GITHUB_OUTPUT"
          echo EOF >> "$GITHUB_OUTPUT"
          cat summary.md >> "$GITHUB_STEP_SUMMARY"

      - name: Create or update governance issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const body  = fs.readFileSync('summary.md', 'utf8');
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const title = 'Automated LFN Project Lifecycle Summary';
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner, repo, labels: 'lfn-governance', state: 'open'
            });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.update({ owner, repo, issue_number: existing.number, body });
              core.info(`Updated issue #${existing.number}`);
            } else {
              await github.rest.issues.create({ owner, repo, title, body, labels: ['lfn-governance'] });
              core.info('Created new governance issue');
            }

      - name: Notify Slack (optional)
        if: ${{ env.SLACK_WEBHOOK_URL != '' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": ":clipboard: LFN governance summary updated for *${{ github.repository }}* – <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|view run>"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
