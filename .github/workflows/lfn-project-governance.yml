# =============================================================================
#  LFN Project Governance Automation Workflow
#  --------------------------------------------------------------------------------
#  PURPOSE
#  -------
#  This workflow aims to provide consistency and engagement to the governance and health-check processes for Projects across all Linux Foundation Networking (LFN) projects. It regularly assesses repositories under LFN's umbrella to ensure continuous alignment with community health, security standards, and lifecycle progression defined by the Technical Advisory Council (TAC). This information will be helpful to the Members of the Board when making strategic decisions. 
#  The timing of the assessment would depend on their lifecycle phase and the metrics being checked. The timing will need to be customizable by the TAC.

#  CORE OBJECTIVES
#  ---------------
#  • **Automated Repository Assessment:**
#    - Periodically scan every repository within the LFN umbrella projects (and induction-candidate repositories).
#    - Read existing health metrics, including commit activity, contributor engagement, release history, and lifecycle status.
#    - Initially designed to operate without requiring elevated permissions or special GitHub GraphQL scopes, ensuring secure, transparent, and community-friendly operation.

#  • **Lifecycle Classification:**
#    - Clearly categorize repositories into one of seven TAC-defined lifecycle phases:
#      1. Spark (Candidate/New)
#      2. Incubation
#      3. Active Development
#      4. Stable
#      5. Maintenance/Long-Term Support (LTS)
#      6. Archive
#      7. Inaccessible (permissions issue or repository not found)
#    - Provide a simple, community-readable summary for easy tracking and oversight by project maintainers, Program Managers (PMs), and the TAC.

#  • **Friendly and Encouraging Community Engagement:**
#    - Automatically create/update one GitHub issue per organization (project-level) with clear, friendly, and actionable next-step suggestions to improve their project's lifecycle status.
#    - Issues will not impose strict deadlines, emphasizing encouragement and constructive guidance, with recommended adjustable check-ins for progress updates.
#    - Repositories classified as "Archive" or "Inaccessible" are intentionally excluded from next-step issues as they have reached terminal phases.

#  FUTURE ENHANCEMENTS
#  -------------------
#  • **Security and Health:**
#    - Incorporate OSSF Scorecard checks
#    - Open tickets to the orgs (project-level) with helpful steps they can take to improve their current OSSF scorecard
#    
#  • **Governance and Leadership:**
#    - Technical Steering Committee (TSC) membership is often submitted as part of Induction levels beyond Spark (and possibly even at Spark), but it is not always maintained in GitHub.  With community 
#      agreement, it may be easier to maintain in GitHub for automation, if we can agree on a standard
#
#  • **Flexible TAC Lifecycle Adjustment:**
#    - Provide a clear, documented mechanism to modify lifecycle phase datapoints based on official TAC approvals (authentication of approvals currently outside workflow scope, maintained by LF staff or authorized community maintainers for now discuss with community).

#  READABILITY & MAINTAINABILITY
#  -----------------------------
#  This workflow is intentionally designed to be both verbose and structured for readability and ease of community collaboration. Community members are encouraged to contribute suggestions, enhancements, or adjustments to the logic to ensure continuous improvement and alignment with community goals.

name: "LFN Project Governance Automation"

on:
  # Manual trigger with selectable mode
  workflow_dispatch:
    inputs:
      mode:
        description: |
          Select workflow run mode:
            • test – Enumerates and classifies repos, generates summary only
            • review – Full lifecycle classification of existing projects
            • induction – Classify and onboard a single new project
        required: true
        default: "test"
        type: choice
        options:
          - test
          - induction
          - review
      project_org:
        description: "(induction only) GitHub org for the new project"
        required: false
      project_repo:
        description: "(induction only) Repository slug <org>/<repo>"
        required: false

permissions:
  contents: read       # needed to read repo metadata
  issues: write        # to create and update governance issues
  pull-requests: write # reserved for future use (e.g., bots)
  id-token: write      # required for OIDC if needed

env:
  GH_TOKEN: ${{ secrets.LFN_ADMIN_TOKEN }}

jobs:
  enumerate-projects:
    # This job builds the matrix of repositories to process
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - name: Install yq (for YAML parsing)
        run: sudo apt-get update -y && sudo apt-get install -y yq

      - name: Build repo matrix
        id: set-matrix
        shell: bash
        env:
          MODE: ${{ github.event.inputs.mode }}
          PROJECT_ORG: ${{ github.event.inputs.project_org }}
          PROJECT_REPO: ${{ github.event.inputs.project_repo }}
        run: |
          if [[ "$MODE" == "induction" ]]; then
            # Single repo provided manually (e.g. onboarding a new project)
            echo "matrix=[\"${PROJECT_ORG}/${PROJECT_REPO}\"]" >> "$GITHUB_OUTPUT"
          else
            # Collect all repos from the defined list of orgs in project config
            declare -a matrix
            for org in $(yq -r '.orgs[]' .lfn/projects.yaml); do
              for repo in $(gh repo list "$org" --json name -q '.[].name'); do
                matrix+=("$org/$repo")
              done
            done
            # Return matrix as a JSON array
            printf '%s\n' "${matrix[@]}" | jq -R . | jq -cs '.' | {
              read json; echo "matrix=$json" >> "$GITHUB_OUTPUT"; }
          fi

  classify:
    # This job analyzes each repo in parallel and determines its lifecycle phase
    needs: enumerate-projects
    runs-on: ubuntu-latest
    if: ${{ needs.enumerate-projects.outputs.matrix != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        repo_slug: ${{ fromJson(needs.enumerate-projects.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
      - name: Load classification thresholds from config
        run: cp .lfn/classify-config.yml ./classify-config.yml

      - name: Convert classify config to JSON
        run: yq -o=json '.phases' .lfn/classify-config.yml > classify-phases.json

      - name: Classify repo lifecycle
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.LFN_ADMIN_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const config = JSON.parse(fs.readFileSync('./classify-phases.json', 'utf8'));
            // Placeholder for actual lifecycle classification using thresholds from config

  publish-report:
    # Build and publish a single markdown report summarizing all classifications
    needs: classify
    runs-on: ubuntu-latest
    if: always()
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Build markdown summary report
        id: build-md
        shell: bash
        run: |
          set -euo pipefail
          declare -A rows
          for dir in artifacts/*; do
            [[ -d "$dir" ]] || continue
            slug=$(basename "$dir")
            slug=${slug%.json}
            full=${slug//--/\/}
            project=${full%%/*}
            repo=${full#*/}
            phase=$(jq -r '.phase // "Unknown"' "$dir/repo.json" 2>/dev/null || echo Unknown)
            if [[ -n "${rows[$project]:-}" ]]; then rows[$project]+=$'\n'; fi
            rows[$project]+="| $repo | $phase |"
          done
          {
            echo "# LFN Project Lifecycle Summary"
            for project in "${!rows[@]}"; do
              echo
              echo "## $project"
              echo "| Repository | Phase |"
              echo "|------------|-------|"
              printf '%s\n' "${rows[$project]}" | sort
            done
          } > summary.md
          echo 'summary<<EOF' >> "$GITHUB_OUTPUT"
          cat summary.md >> "$GITHUB_OUTPUT"
          echo EOF >> "$GITHUB_OUTPUT"
          cat summary.md >> "$GITHUB_STEP_SUMMARY"

      - name: Create or update governance summary issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('summary.md', 'utf8');
            const { owner, repo } = context.repo;
            const title = 'Automated LFN Project Lifecycle Summary';
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner, repo, labels: 'lfn-governance', state: 'open'
            });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.update({ owner, repo, issue_number: existing.number, body });
            } else {
              await github.rest.issues.create({ owner, repo, title, body, labels: ['lfn-governance'] });
            }

  publish-issues:
    # Creates or updates per-project issues to guide community improvements
    # This step is skipped in test mode to avoid unnecessary GitHub noise
    needs: [classify, enumerate-projects]
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.mode != 'test' }}
    steps:
      - uses: actions/checkout@v4
      - name: Load issue config
        run: cp .lfn/issues-config.yml ./issues-config.yml
      - name: Create or update lifecycle issues per org
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.LFN_ADMIN_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            const config = yaml.load(fs.readFileSync('./issues-config.yml', 'utf8'));
            // Placeholder for future per-phase issue logic

