# =============================================================================
#  LFN Project Governance Automation Workflow
#  --------------------------------------------------------------------------------
#  PURPOSE
#  -------
#  This workflow aims to provide consistency and engagement to the governance and health-check processes for Projects across all Linux Foundation Networking (LFN) projects. It regularly assesses repositories under LFN's umbrella to ensure continuous alignment with community health, security standards, and lifecycle progression defined by the Technical Advisory Council (TAC). This information will be helpful to the Members of the Board when making strategic decisions. 
#  The timing of the assessment would depend on their lifecycle phase and the metrics being checked. The timing will need to be customizable by the TAC.

#  CORE OBJECTIVES
#  ---------------
#  • **Automated Repository Assessment:**
#    - Periodically scan every repository within the LFN umbrella projects (and induction-candidate repositories).
#    - Read existing health metrics, including commit activity, contributor engagement, release history, and lifecycle status.
#    - Initially designed to operate without requiring elevated permissions or special GitHub GraphQL scopes, ensuring secure, transparent, and community-friendly operation.

#  • **Lifecycle Classification:**
#    - Clearly categorize repositories into one of seven TAC-defined lifecycle phases:
#      1. Spark (Candidate/New)
#      2. Incubation
#      3. Active Development
#      4. Stable
#      5. Maintenance/Long-Term Support (LTS)
#      6. Archive
#      7. Inaccessible (permissions issue or repository not found)
#    - Provide a simple, community-readable summary for easy tracking and oversight by project maintainers, Program Managers (PMs), and the TAC.

#  • **Friendly and Encouraging Community Engagement:**
#    - Automatically create/update one GitHub issue per organization (project-level) with clear, friendly, and actionable next-step suggestions to improve their project's lifecycle status.
#    - Issues will not impose strict deadlines, emphasizing encouragement and constructive guidance, with recommended quarterly check-ins for progress updates.
#    - Repositories classified as "Archive" or "Inaccessible" are intentionally excluded from next-step issues as they have reached terminal phases.

#  FUTURE ENHANCEMENTS
#  -------------------
#  • **Security and Health:**
#    - Incorporate OSSF Scorecard checks
#    - Open tickets to the orgs (project-level) with helpful steps they can take to improve their current OSSF scorecard
#    
#  • **Governance and Leadership:**
#    - Technical Steering Committee (TSC) membership is often submitted as part of Induction levels beyond Spark (and possibly even at Spark), but it is not always maintained in GitHub.  With community 
#      agreement, it may be easier to maintain in GitHub for automation, if we can agree on a standard
#
#  • **Flexible TAC Lifecycle Adjustment:**
#    - Provide a clear, documented mechanism to modify lifecycle phase datapoints based on official TAC approvals (authentication of approvals currently outside workflow scope, maintained by LF staff or authorized community maintainers for now discuss with community).

#  READABILITY & MAINTAINABILITY
#  -----------------------------
#  This workflow is intentionally designed to be both verbose and structured for readability and ease of community collaboration. Community members are encouraged to contribute suggestions, enhancements, or adjustments to the logic to ensure continuous improvement and alignment with community goals.


name: "LFN Project Governance Automation"

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Choose the run mode"
        required: true
        default: "review"
        type: choice
        options: [review, induction]
      project_org:
        description: "(induction) GitHub org where the new project lives"
        required: false
      project_repo:
        description: "(induction) Repository slug <org>/<repo>"
        required: false
  schedule:
    - cron: "0 9 * * 1"   # 09:00 UTC Monday → 02:00 PT

permissions:
  contents: read
  issues:   write
  pull-requests: write
  id-token: write

env:
  GH_TOKEN: ${{ secrets.LFN_ADMIN_TOKEN }}

jobs:
  enumerate-projects:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Install yq
        run: sudo apt-get update -y && sudo apt-get install -y yq

      - name: Build repo matrix
        id: set-matrix
        shell: bash
        env:
          MODE: ${{ github.event.inputs.mode || 'review' }}
          PROJECT_ORG: ${{ github.event.inputs.project_org }}
          PROJECT_REPO: ${{ github.event.inputs.project_repo }}
        run: |
          set -euo pipefail
          if [[ "$MODE" == "induction" ]]; then
            echo "matrix=[\"${PROJECT_ORG}/${PROJECT_REPO}\"]" >> "$GITHUB_OUTPUT"
          else
            declare -a matrix
            for org in $(yq -r '.orgs[]' .lfn/projects.yaml); do
              echo "📦 $org" >&2
              for repo in $(gh repo list "$org" --json name -q '.[].name'); do
                matrix+=("$org/$repo")
              done
            done
            printf '%s\n' "${matrix[@]}" | jq -R . | jq -cs '.' | {
              read json; echo "matrix=$json" >> "$GITHUB_OUTPUT"; echo "Matrix: $json" >&2; }
          fi

  classify:
    needs: enumerate-projects
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        repo_slug: ${{ fromJson(needs.enumerate-projects.outputs.matrix) }}
    steps:
      - name: GitHub CLI auth debug
        run: |
          echo "== gh auth status ==" && gh auth status || true
        env:
          GH_TOKEN: ${{ secrets.LFN_ADMIN_TOKEN }}

      - name: Collect repository metrics (REST‑only)
        id: metrics
        shell: bash
        env:
          REPO: ${{ matrix.repo_slug }}
        run: |
          set -euo pipefail
          owner="${REPO%%/*}"
          repo="${REPO#*/}"
          if ! gh api "/repos/$owner/$repo" > repo.json 2>err.log; then
            echo "⚠️  $REPO – $(cat err.log)" >&2
            echo '{}' > repo.json
          fi
          echo "json=$(cat repo.json)" >> "$GITHUB_OUTPUT"

      - name: Determine lifecycle phase (7‑phase rubric)
        id: phase
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.LFN_ADMIN_TOKEN }}
          script: |
            /* -------------------------------------------------------------------------
             *  LIFECYCLE CLASSIFICATION LOGIC (Spark → Incubation → Active → Stable → LTS
             *  → Archive → Inaccessible)
             *  -----------------------------------------------------------------------
             *  This block ingests a minimal *repo.json* produced by the previous step
             *  and derives a PHASE string.  We purposefully rely **only** on public
             *  REST v3 endpoints so that the workflow can run with the default GITHUB_TOKEN.
             *
             *  ────────────────  METRICS WE EXTRACT ─────────────────
             *   • contributors   – unique identities ever contributing code (proxy diversity)
             *   • commits90d     – commits in the rolling 90‑day window (proxy velocity)
             *   • silent         – days since last push (proxy dormancy)
             *   • ageYrs         – project age in *years*
             *   • lastRelDays    – days since the most recent GitHub Release
             *   • hasRelease     – boolean shortcut (≥1 release exists)
             *
             *  ────────────────  DECISION PLAYBOOK ───────────────────
             *   1.  Inaccessible  → API call failed (private/moved/deleted).
             *   2.  Archive       → GitHub “archived” flag true.
             *   3.  Spark         → very small (<3 contrib) OR zero releases.
             *   4.  Incubation    → enough contrib (≥3) *and* at least one release,
             *                       but still low velocity / early adoption.
             *   5.  Active Dev    → ≥20 commits in 90 days **and** last push ≤30 days.
             *   6.  Stable        → No longer active dev, but push within 30‑180 days.
             *   7.  Maintenance   → Age ≥5 yrs, low activity (>180 days) *yet* produced
             *                       a release within the last 2 years (≤730 days).
             *
             *  We break ties by checking the more *specific* phases first. For instance,
             *  a repo can be both Active *and* Incubation, but Active wins due to order.
             * ------------------------------------------------------------------------- */

            const repoJson  = JSON.parse(process.env.REPO_JSON || '{}');
            const slug      = process.env.REPO_SLUG || '';
            const [owner, repoName] = slug.split('/');

            // Helper – convert ISO dates → days delta
            const daysAgo = iso => (Date.now() - new Date(iso)) / 864e5;

            // ────────────────────── 1 · DEFAULT → Unknown ──────────────────────
            let phase = 'Unknown';

            // ────────────────────── 2 · INACCESSIBLE ───────────────────────────
            if (!Object.keys(repoJson).length) {
              phase = 'Inaccessible';
            }
            // ────────────────────── 3 · ARCHIVE (explicit flag) ────────────────
            else if (repoJson.archived) {
              phase = 'Archive';
            } else {
              /* Grab dynamic repo activity figures.  We wrap each call in a try/catch so
               * a 404 or rate‑limit for an individual endpoint doesn’t abort the workflow.
               */

              // → unique contributor count (overall)
              let contributors = 0;
              try {
                const { data: contrib } = await github.rest.repos.listContributors({
                  owner, repo: repoName, per_page: 100, anon: true });
                contributors = contrib.length;
              } catch (_) {/* swallow */}

              // → dormancy (days since last push)
              const silent = daysAgo(repoJson.pushed_at ?? repoJson.updated_at);

              // → project age in years
              const ageYrs = (Date.now() - new Date(repoJson.created_at)) / (365 * 864e5);

              // → latest release age (if any)
              let lastRelDays = Infinity;
              let hasRelease  = false;
              try {
                const { data: rel } = await github.rest.repos.getLatestRelease({ owner, repo: repoName });
                lastRelDays = daysAgo(rel.published_at);
                hasRelease  = true;
              } catch (_) {/* no releases */}

              // → commit velocity (rolling 90 days)
              let commits90d = 0;
              try {
                const sinceISO = new Date(Date.now() - 90 * 864e5).toISOString();
                const commits  = await github.paginate(github.rest.repos.listCommits, {
                  owner, repo: repoName, since: sinceISO, per_page: 100 });
                commits90d = commits.length;
              } catch (_) {}

              /*  Boolean helper flags for readability  */
              const isSpark  = (contributors < 3) || !hasRelease;
              const isIncub  = !isSpark && contributors >= 3 && hasRelease;
              const isActive = commits90d >= 20 && silent <= 30;
              const isStable = !isActive && silent > 30 && silent <= 180;
              const isLTS    = ageYrs >= 5 && silent > 180 && silent <= 540 && lastRelDays <= 730;

              // ────────────────────── FINAL PHASE CHOICE ───────────────────────
              if      (isSpark)  phase = 'Spark';
              else if (isIncub)  phase = 'Incubation';
              else if (isActive) phase = 'Active Development';
              else if (isStable) phase = 'Stable';
              else if (isLTS)    phase = 'Maintenance / LTS';
              else               phase = 'Unknown'; // fallback (should be rare)
            }

            core.setOutput('phase', phase);
            // Persist for the publish job
            const fs = require('fs');
            fs.writeFileSync('repo.json', JSON.stringify({ phase }, null, 2));
        env:
          REPO_JSON: ${{ steps.metrics.outputs.json }}
          REPO_SLUG: ${{ matrix.repo_slug }}

      - name: Sanitize artifact name
        shell: bash
        env:
          REPO: ${{ matrix.repo_slug }}
        run: |
          safe="${REPO//\//--}"
          echo "ART_NAME=$safe" >> $GITHUB_ENV

      - name: Upload result
        uses: actions/upload-artifact@v4
        with:
          name: "${{ env.ART_NAME }}.json"
          path: repo.json

  publish-report:
    needs: classify
    runs-on: ubuntu-latest
    if: always()
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: artifacts

      - id: build-md
        shell: bash
        run: |
          set -euo pipefail
          declare -A rows
          for dir in artifacts/*; do
            [[ -d "$dir" ]] || continue
            slug=$(basename "$dir")
            slug=${slug%.json}
            full=${slug//--/\/}
            project=${full%%/*}
            repo=${full#*/}
            phase=$(jq -r '.phase // "Unknown"' "$dir/repo.json" 2>/dev/null || echo Unknown)
            if [[ -n "${rows[$project]:-}" ]]; then rows[$project]+=$'\n'; fi
            rows[$project]+="| $repo | $phase |"
          done
          {
            echo "# LFN Project Lifecycle Summary"
            for project in "${!rows[@]}"; do
              echo
              echo "## $project"
              echo "| Repository | Phase |"
              echo "|------------|-------|"
              printf '%s\n' "${rows[$project]}" | sort
            done
          } > summary.md
          echo 'summary<<EOF' >> "$GITHUB_OUTPUT"
          cat summary.md >> "$GITHUB_OUTPUT"
          echo EOF >> "$GITHUB_OUTPUT"
          cat summary.md >> "$GITHUB_STEP_SUMMARY"

      - name: Create or update governance issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const body  = fs.readFileSync('summary.md', 'utf8');
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const title = 'Automated LFN Project Lifecycle Summary';
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner, repo, labels: 'lfn-governance', phase: 'open'
            });
            const existing = issues.find(i => i.title === title);
            if (existing) {
              await github.rest.issues.update({ owner, repo, issue_number: existing.number, body });
              core.info(`Updated issue #${existing.number}`);
            } else {
              await github.rest.issues.create({ owner, repo, title, body, labels: ['lfn-governance'] });
              core.info('Created new governance issue');
            }

      - name: Notify Slack (optional)  
        if: ${{ env.SLACK_WEBHOOK_URL != '' }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": ":clipboard: LFN governance summary updated for *${{ github.repository }}* – <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|view run>"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
